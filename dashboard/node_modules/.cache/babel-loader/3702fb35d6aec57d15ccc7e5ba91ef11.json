{"ast":null,"code":"import * as t from \"react\";\nimport { memo as e, useMemo as i, createElement as n } from \"react\";\nimport { animated as r, useSpring as a, useTransition as o } from \"@react-spring/web\";\nimport { textPropsByEngine as l, useTheme as s, useMotionConfig as c, degreesToRadians as f } from \"@nivo/core\";\nimport { timeFormat as x } from \"d3-time-format\";\nimport { format as u } from \"d3-format\";\nimport { getScaleTicks as d, centerScale as m } from \"@nivo/scales\";\nimport { jsxs as y, jsx as g, Fragment as k } from \"react/jsx-runtime\";\nimport h from \"prop-types\";\nfunction v() {\n  return v = Object.assign || function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var i = arguments[e];\n      for (var n in i) {\n        Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n]);\n      }\n    }\n    return t;\n  }, v.apply(this, arguments);\n}\nvar p = function p(t) {\n    var e,\n      i = t.axis,\n      n = t.scale,\n      r = t.ticksPosition,\n      a = t.tickValues,\n      o = t.tickSize,\n      s = t.tickPadding,\n      c = t.tickRotation,\n      f = t.engine,\n      x = void 0 === f ? \"svg\" : f,\n      u = d(n, a),\n      y = l[x],\n      g = \"bandwidth\" in n ? m(n) : n,\n      k = {\n        lineX: 0,\n        lineY: 0\n      },\n      h = {\n        textX: 0,\n        textY: 0\n      },\n      p = \"object\" == typeof document && \"rtl\" === document.dir,\n      b = y.align.center,\n      P = y.baseline.center;\n    return \"x\" === i ? (e = function e(t) {\n      var e;\n      return {\n        x: null != (e = g(t)) ? e : 0,\n        y: 0\n      };\n    }, k.lineY = o * (\"after\" === r ? 1 : -1), h.textY = (o + s) * (\"after\" === r ? 1 : -1), P = \"after\" === r ? y.baseline.top : y.baseline.bottom, 0 === c ? b = y.align.center : \"after\" === r && c < 0 || \"before\" === r && c > 0 ? (b = y.align[p ? \"left\" : \"right\"], P = y.baseline.center) : (\"after\" === r && c > 0 || \"before\" === r && c < 0) && (b = y.align[p ? \"right\" : \"left\"], P = y.baseline.center)) : (e = function e(t) {\n      var e;\n      return {\n        x: 0,\n        y: null != (e = g(t)) ? e : 0\n      };\n    }, k.lineX = o * (\"after\" === r ? 1 : -1), h.textX = (o + s) * (\"after\" === r ? 1 : -1), b = \"after\" === r ? y.align.left : y.align.right), {\n      ticks: u.map(function (t) {\n        return v({\n          key: t instanceof Date ? \"\" + t.valueOf() : \"\" + t,\n          value: t\n        }, e(t), k, h);\n      }),\n      textAlign: b,\n      textBaseline: P\n    };\n  },\n  b = function b(t, e) {\n    if (void 0 === t || \"function\" == typeof t) return t;\n    if (\"time\" === e.type) {\n      var i = x(t);\n      return function (t) {\n        return i(t instanceof Date ? t : new Date(t));\n      };\n    }\n    return u(t);\n  },\n  P = function P(t) {\n    var e,\n      i = t.width,\n      n = t.height,\n      r = t.scale,\n      a = t.axis,\n      o = t.values,\n      l = (e = o, Array.isArray(e) ? o : void 0) || d(r, o),\n      s = \"bandwidth\" in r ? m(r) : r,\n      c = \"x\" === a ? l.map(function (t) {\n        var e, i;\n        return {\n          key: t instanceof Date ? \"\" + t.valueOf() : \"\" + t,\n          x1: null != (e = s(t)) ? e : 0,\n          x2: null != (i = s(t)) ? i : 0,\n          y1: 0,\n          y2: n\n        };\n      }) : l.map(function (t) {\n        var e, n;\n        return {\n          key: t instanceof Date ? \"\" + t.valueOf() : \"\" + t,\n          x1: 0,\n          x2: i,\n          y1: null != (e = s(t)) ? e : 0,\n          y2: null != (n = s(t)) ? n : 0\n        };\n      });\n    return c;\n  },\n  S = e(function (t) {\n    var e,\n      n = t.value,\n      a = t.format,\n      o = t.lineX,\n      l = t.lineY,\n      c = t.onClick,\n      f = t.textBaseline,\n      x = t.textAnchor,\n      u = t.animatedProps,\n      d = s(),\n      m = null != (e = null == a ? void 0 : a(n)) ? e : n,\n      k = i(function () {\n        var t = {\n          opacity: u.opacity\n        };\n        return c ? {\n          style: v({}, t, {\n            cursor: \"pointer\"\n          }),\n          onClick: function onClick(t) {\n            return c(t, m);\n          }\n        } : {\n          style: t\n        };\n      }, [u.opacity, c, m]);\n    return y(r.g, v({\n      transform: u.transform\n    }, k, {\n      children: [g(\"line\", {\n        x1: 0,\n        x2: o,\n        y1: 0,\n        y2: l,\n        style: d.axis.ticks.line\n      }), g(r.text, {\n        dominantBaseline: f,\n        textAnchor: x,\n        transform: u.textTransform,\n        style: d.axis.ticks.text,\n        children: m\n      })]\n    }));\n  }),\n  T = e(function (e) {\n    var n = e.axis,\n      l = e.scale,\n      f = e.x,\n      x = void 0 === f ? 0 : f,\n      u = e.y,\n      d = void 0 === u ? 0 : u,\n      m = e.length,\n      k = e.ticksPosition,\n      h = e.tickValues,\n      P = e.tickSize,\n      T = void 0 === P ? 5 : P,\n      O = e.tickPadding,\n      w = void 0 === O ? 5 : O,\n      A = e.tickRotation,\n      X = void 0 === A ? 0 : A,\n      Y = e.format,\n      W = e.renderTick,\n      B = void 0 === W ? S : W,\n      z = e.legend,\n      V = e.legendPosition,\n      C = void 0 === V ? \"end\" : V,\n      D = e.legendOffset,\n      R = void 0 === D ? 0 : D,\n      j = e.onClick,\n      E = e.ariaHidden,\n      q = s(),\n      F = i(function () {\n        return b(Y, l);\n      }, [Y, l]),\n      H = p({\n        axis: n,\n        scale: l,\n        ticksPosition: k,\n        tickValues: h,\n        tickSize: T,\n        tickPadding: w,\n        tickRotation: X\n      }),\n      N = H.ticks,\n      I = H.textAlign,\n      G = H.textBaseline,\n      J = null;\n    if (void 0 !== z) {\n      var K,\n        L = 0,\n        M = 0,\n        Q = 0;\n      \"y\" === n ? (Q = -90, L = R, \"start\" === C ? (K = \"start\", M = m) : \"middle\" === C ? (K = \"middle\", M = m / 2) : \"end\" === C && (K = \"end\")) : (M = R, \"start\" === C ? K = \"start\" : \"middle\" === C ? (K = \"middle\", L = m / 2) : \"end\" === C && (K = \"end\", L = m)), J = g(\"text\", {\n        transform: \"translate(\" + L + \", \" + M + \") rotate(\" + Q + \")\",\n        textAnchor: K,\n        style: v({\n          dominantBaseline: \"central\"\n        }, q.axis.legend.text),\n        children: z\n      });\n    }\n    var U = c(),\n      Z = U.animate,\n      $ = U.config,\n      _ = a({\n        transform: \"translate(\" + x + \",\" + d + \")\",\n        lineX2: \"x\" === n ? m : 0,\n        lineY2: \"x\" === n ? 0 : m,\n        config: $,\n        immediate: !Z\n      }),\n      tt = o(N, {\n        keys: function keys(t) {\n          return t.key;\n        },\n        initial: function initial(t) {\n          return {\n            opacity: 1,\n            transform: \"translate(\" + t.x + \",\" + t.y + \")\",\n            textTransform: \"translate(\" + t.textX + \",\" + t.textY + \") rotate(\" + X + \")\"\n          };\n        },\n        from: function from(t) {\n          return {\n            opacity: 0,\n            transform: \"translate(\" + t.x + \",\" + t.y + \")\",\n            textTransform: \"translate(\" + t.textX + \",\" + t.textY + \") rotate(\" + X + \")\"\n          };\n        },\n        enter: function enter(t) {\n          return {\n            opacity: 1,\n            transform: \"translate(\" + t.x + \",\" + t.y + \")\",\n            textTransform: \"translate(\" + t.textX + \",\" + t.textY + \") rotate(\" + X + \")\"\n          };\n        },\n        update: function update(t) {\n          return {\n            opacity: 1,\n            transform: \"translate(\" + t.x + \",\" + t.y + \")\",\n            textTransform: \"translate(\" + t.textX + \",\" + t.textY + \") rotate(\" + X + \")\"\n          };\n        },\n        leave: {\n          opacity: 0\n        },\n        config: $,\n        immediate: !Z\n      });\n    return y(r.g, {\n      transform: _.transform,\n      \"aria-hidden\": E,\n      children: [tt(function (e, i, n, r) {\n        return t.createElement(B, v({\n          tickIndex: r,\n          format: F,\n          rotate: X,\n          textBaseline: G,\n          textAnchor: I,\n          animatedProps: e\n        }, i, j ? {\n          onClick: j\n        } : {}));\n      }), g(r.line, {\n        style: q.axis.domain.line,\n        x1: 0,\n        x2: _.lineX2,\n        y1: 0,\n        y2: _.lineY2\n      }), J]\n    });\n  }),\n  O = {\n    ticksPosition: h.oneOf([\"before\", \"after\"]),\n    tickValues: h.oneOfType([h.number, h.arrayOf(h.oneOfType([h.number, h.string, h.instanceOf(Date)])), h.string]),\n    tickSize: h.number,\n    tickPadding: h.number,\n    tickRotation: h.number,\n    format: h.oneOfType([h.func, h.string]),\n    renderTick: h.func,\n    legend: h.node,\n    legendPosition: h.oneOf([\"start\", \"middle\", \"end\"]),\n    legendOffset: h.number,\n    ariaHidden: h.bool\n  },\n  w = h.shape(O),\n  A = [\"top\", \"right\", \"bottom\", \"left\"],\n  X = e(function (t) {\n    var e = t.xScale,\n      i = t.yScale,\n      n = t.width,\n      r = t.height,\n      a = {\n        top: t.top,\n        right: t.right,\n        bottom: t.bottom,\n        left: t.left\n      };\n    return g(k, {\n      children: A.map(function (t) {\n        var o = a[t];\n        if (!o) return null;\n        var l = \"top\" === t || \"bottom\" === t;\n        return g(T, v({}, o, {\n          axis: l ? \"x\" : \"y\",\n          x: \"right\" === t ? n : 0,\n          y: \"bottom\" === t ? r : 0,\n          scale: l ? e : i,\n          length: l ? n : r,\n          ticksPosition: \"top\" === t || \"left\" === t ? \"before\" : \"after\"\n        }), t);\n      })\n    });\n  }),\n  Y = e(function (t) {\n    var e = t.animatedProps,\n      i = s();\n    return g(r.line, v({}, e, i.grid.line));\n  }),\n  W = e(function (t) {\n    var e = t.lines,\n      i = c(),\n      r = i.animate,\n      a = i.config,\n      l = o(e, {\n        keys: function keys(t) {\n          return t.key;\n        },\n        initial: function initial(t) {\n          return {\n            opacity: 1,\n            x1: t.x1,\n            x2: t.x2,\n            y1: t.y1,\n            y2: t.y2\n          };\n        },\n        from: function from(t) {\n          return {\n            opacity: 0,\n            x1: t.x1,\n            x2: t.x2,\n            y1: t.y1,\n            y2: t.y2\n          };\n        },\n        enter: function enter(t) {\n          return {\n            opacity: 1,\n            x1: t.x1,\n            x2: t.x2,\n            y1: t.y1,\n            y2: t.y2\n          };\n        },\n        update: function update(t) {\n          return {\n            opacity: 1,\n            x1: t.x1,\n            x2: t.x2,\n            y1: t.y1,\n            y2: t.y2\n          };\n        },\n        leave: {\n          opacity: 0\n        },\n        config: a,\n        immediate: !r\n      });\n    return g(\"g\", {\n      children: l(function (t, e) {\n        return n(Y, v({}, e, {\n          key: e.key,\n          animatedProps: t\n        }));\n      })\n    });\n  }),\n  B = e(function (t) {\n    var e = t.width,\n      n = t.height,\n      r = t.xScale,\n      a = t.yScale,\n      o = t.xValues,\n      l = t.yValues,\n      s = i(function () {\n        return !!r && P({\n          width: e,\n          height: n,\n          scale: r,\n          axis: \"x\",\n          values: o\n        });\n      }, [r, o, e, n]),\n      c = i(function () {\n        return !!a && P({\n          width: e,\n          height: n,\n          scale: a,\n          axis: \"y\",\n          values: l\n        });\n      }, [n, e, a, l]);\n    return y(k, {\n      children: [s && g(W, {\n        lines: s\n      }), c && g(W, {\n        lines: c\n      })]\n    });\n  }),\n  z = function z(t, e) {\n    var i,\n      n = e.axis,\n      r = e.scale,\n      a = e.x,\n      o = void 0 === a ? 0 : a,\n      l = e.y,\n      s = void 0 === l ? 0 : l,\n      c = e.length,\n      x = e.ticksPosition,\n      u = e.tickValues,\n      d = e.tickSize,\n      m = void 0 === d ? 5 : d,\n      y = e.tickPadding,\n      g = void 0 === y ? 5 : y,\n      k = e.tickRotation,\n      h = void 0 === k ? 0 : k,\n      v = e.format,\n      b = e.legend,\n      P = e.legendPosition,\n      S = void 0 === P ? \"end\" : P,\n      T = e.legendOffset,\n      O = void 0 === T ? 0 : T,\n      w = e.theme,\n      A = p({\n        axis: n,\n        scale: r,\n        ticksPosition: x,\n        tickValues: u,\n        tickSize: m,\n        tickPadding: g,\n        tickRotation: h,\n        engine: \"canvas\"\n      }),\n      X = A.ticks,\n      Y = A.textAlign,\n      W = A.textBaseline;\n    t.save(), t.translate(o, s), t.textAlign = Y, t.textBaseline = W, t.font = (w.axis.ticks.text.fontWeight ? w.axis.ticks.text.fontWeight + \" \" : \"\") + w.axis.ticks.text.fontSize + \"px \" + w.axis.ticks.text.fontFamily, (null != (i = w.axis.domain.line.strokeWidth) ? i : 0) > 0 && (t.lineWidth = Number(w.axis.domain.line.strokeWidth), t.lineCap = \"square\", w.axis.domain.line.stroke && (t.strokeStyle = w.axis.domain.line.stroke), t.beginPath(), t.moveTo(0, 0), t.lineTo(\"x\" === n ? c : 0, \"x\" === n ? 0 : c), t.stroke());\n    var B = \"function\" == typeof v ? v : function (t) {\n      return \"\" + t;\n    };\n    if (X.forEach(function (e) {\n      var i;\n      (null != (i = w.axis.ticks.line.strokeWidth) ? i : 0) > 0 && (t.lineWidth = Number(w.axis.ticks.line.strokeWidth), t.lineCap = \"square\", w.axis.ticks.line.stroke && (t.strokeStyle = w.axis.ticks.line.stroke), t.beginPath(), t.moveTo(e.x, e.y), t.lineTo(e.x + e.lineX, e.y + e.lineY), t.stroke());\n      var n = B(e.value);\n      t.save(), t.translate(e.x + e.textX, e.y + e.textY), t.rotate(f(h)), w.axis.ticks.text.fill && (t.fillStyle = w.axis.ticks.text.fill), t.fillText(String(n), 0, 0), t.restore();\n    }), void 0 !== b) {\n      var z = 0,\n        V = 0,\n        C = 0,\n        D = \"center\";\n      \"y\" === n ? (C = -90, z = O, \"start\" === S ? (D = \"start\", V = c) : \"middle\" === S ? (D = \"center\", V = c / 2) : \"end\" === S && (D = \"end\")) : (V = O, \"start\" === S ? D = \"start\" : \"middle\" === S ? (D = \"center\", z = c / 2) : \"end\" === S && (D = \"end\", z = c)), t.translate(z, V), t.rotate(f(C)), t.font = (w.axis.legend.text.fontWeight ? w.axis.legend.text.fontWeight + \" \" : \"\") + w.axis.legend.text.fontSize + \"px \" + w.axis.legend.text.fontFamily, w.axis.legend.text.fill && (t.fillStyle = w.axis.legend.text.fill), t.textAlign = D, t.textBaseline = \"middle\", t.fillText(b, 0, 0);\n    }\n    t.restore();\n  },\n  V = function V(t, e) {\n    var i = e.xScale,\n      n = e.yScale,\n      r = e.width,\n      a = e.height,\n      o = e.top,\n      l = e.right,\n      s = e.bottom,\n      c = e.left,\n      f = e.theme,\n      x = {\n        top: o,\n        right: l,\n        bottom: s,\n        left: c\n      };\n    A.forEach(function (e) {\n      var o = x[e];\n      if (!o) return null;\n      var l = \"top\" === e || \"bottom\" === e,\n        s = \"top\" === e || \"left\" === e ? \"before\" : \"after\",\n        c = l ? i : n,\n        u = b(o.format, c);\n      z(t, v({}, o, {\n        axis: l ? \"x\" : \"y\",\n        x: \"right\" === e ? r : 0,\n        y: \"bottom\" === e ? a : 0,\n        scale: c,\n        format: u,\n        length: l ? r : a,\n        ticksPosition: s,\n        theme: f\n      }));\n    });\n  },\n  C = function C(t, e) {\n    var i = e.width,\n      n = e.height,\n      r = e.scale,\n      a = e.axis,\n      o = e.values;\n    P({\n      width: i,\n      height: n,\n      scale: r,\n      axis: a,\n      values: o\n    }).forEach(function (e) {\n      t.beginPath(), t.moveTo(e.x1, e.y1), t.lineTo(e.x2, e.y2), t.stroke();\n    });\n  };\nexport { X as Axes, T as Axis, S as AxisTick, B as Grid, Y as GridLine, W as GridLines, w as axisPropType, O as axisPropTypes, A as positions, V as renderAxesToCanvas, z as renderAxisToCanvas, C as renderGridLinesToCanvas };","map":null,"metadata":{},"sourceType":"module"}